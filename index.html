<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>WearHacks 2015</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>WearHacks 2015</h1>
					<h3>How do you communicate?</h3>
					<p>
						<small>Created by Mathieu Gagn&eacute;</small>
					</p>
				</section>

				<section>
					<h2>['hip', 'hip']</h2>
					<h3 class='fragment'>Hip Hip Array!</h3>
				</section>

        <section>
          <h3>Who Am I</h3>

          <aside class="notes">
            I spend my work days writing ruby for web applications and scripts alike.
            I do networky things and all. Unfortunately I don't have the chance to play
            more with the Internet of Things and making my house the nerdiest place ever.
          </aside>
        </section>

        <section data-background="img/zombie-door-opener.jpg">

          <aside class="notes">
            This is the zombie finger door opener. Guys of Many by Many made this
            to buzz open the door downstairs.
            So considering I had little experience in the field. I thought..
          </aside>
        </section>

        <!-- <section>
          <img src="img/what-to-talk-about.jpg" alt="" />

          <aside class="notes">
            And it dawned on me that every software has this central idea at its core.
          </aside>
        </section> -->

        <section>
          <h2>Communication</h2>

          <aside class="notes">
            Software is all about sending messages.
            And what's fun is getting into a ..
          </aside>
        </section>

        <!-- <section>
          <h2>Monologue</h2>
          <h3>Your inner dialect</h3>

          <aside class="notes">
            In your code you have command and query messages.
            Some methods/functions that return something and change nothing. Some that
            change something and return nothing. And of course some that do both.
            But all this communication happens within your program.
            It's a monologue really. A project talking to itself.
            Communication is one thing. But when you want to have a long lasting call,
            something more than a chit chat on Plenty of Fish, you need to initiate a
            conversation.
          </aside>
        </section> -->

        <section>
          <h2>Conversation</h2>

          <aside class="notes">
            There are quite a few ways to converse.
            Some systems decide to broadcast.
            Others constantly poke you.
          </aside>
        </section>

        <section>
          <h2>Conversation</h2>
          <h3 class='fragment'></h3>

          <aside class="notes">
            There are quite a few ways to converse.
            Monologues, Dialogues, Polylogues or Multilgues.

            Others constantly poke you.
          </aside>
        </section>

        <section>
          <h3>Ajax Polling</h3>
          <img src="img/are-we-there-yet.jpg" alt="" />

        </section>

        <section>
          Flash
        </section>

        <section>
          <h3>Ajax Long Polling</h3>
          <img src="img/are-we-there-yet.jpg" alt="" />
          <aside class="notes">
            Pretty much the same, except you should image Bart shut up after the first time.
          </aside>
        </section>

        <section>
          Server-Sent Events
        </section>

        <section>
          <aside class="notes">
            However, all of these work-arounds share one problem: They carry the overhead of HTTP,
            which doesnâ€™t make them well suited for low latency applications.
            The WebSocket specification introduces an API for persistent connection between the client and the server
            where both parties can start sending data at any time.
          </aside>
        </section>

        <section>
          <h2>WebSockets</h2>
          <img src="img/websocket.png" alt="" />

          <aside class="notes">
            WebSockets are often used in games. You want to update all browsers
            with everyone else's information. You also want the players to send
            their movements along. Chat applications are also a typical usage.
          </aside>
        </section>

        <section>

WebSocket libraries for supported runtimes:

(NodeJS) socket.io
(NodeJS) ws
(NodeJS) WebSocket-Node
(Ruby) em-websocket
(Python) Websocket-For-Python
(Python) Twisted
(Python) autobahn
(Python) pywebsocket
(Python) Tornado

          Node.js

Socket.IO
WebSocket-Node
ws
Java

Grizzly
Apache Tomcat 7
Jetty
Atmosphere
Ruby

EventMachine
Faye WebSocket
Python

pywebsocket
Tornado
PHP

Rachet
Php Websocket

C++: libwebsockets
Errlang: Shirasu.ws
Java: Jetty
Node.JS: ws
Ruby: em-websocket
Python: Tornado, pywebsocket
PHP: Ratchet, phpws
        </section>

        <section>
          Pusher
          Socket.io
        </section>

        <section>
          <pre><code class='js javascript' data-trim>var ws = new WebSocket("ws://example.com/")</code></pre>
          <pre class='fragment'><code class='js javascript' data-trim>ws.onopen = function(event) {
  console.log('WebSocket opened.');
}

ws.onclose = function(event) {
  console.log('WebSocket closed.');
  reconnect();
}</code></pre>
          <pre class='fragment'><code class='js javascript' data-trim>ws.onerror = function(event) {
  var notification = new Notification(event);
  reconnect();
}</code></pre>
          <pre class='fragment'><code class='js javascript' data-trim>ws.onmessage = function(event) {
  console.log(event.data);
}
</code></pre>
          <pre class='fragment'><code class='js javascript' data-trim>ws.send("Whatever you want.");</code></pre>
        </section>

        <section>
          Hipster Battle!
        </section>

        <section>
          <h2>Effective Collaboration</h2>
          <h4>Redis & WebSocket</h4>
        </section>

        <section>
          <h2>Have Fun!</h2>

          <aside class="notes">
            I can't wait to see your projects tomorrow.
          </aside>
        </section>

        <section>
          <blockquote>
            To understand what recursion is, you must first understand recursion.
          </blockquote>
        </section>

        <section>
          <pre><code data-trim>while(!asleep()) sheep++</code></pre>
        </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
